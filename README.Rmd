# R Pipeline DSL

This repository contains a prototype and a proposal document for an R language pipeline DSL.

## Prototype

The prototype is located in the `prototype.R` file. You can view more complex examples of the prototype in the `examples` directory.

```{R}
source("prototype.R")
```

To construct a pipeline, specify each stage using the `stage` function. To assemble the stages together into a pipeline use the `make_pipeline` function:

```{R}
pipeline <- make_pipeline(
    stage1 = stage(body = function() "hello world"),
    stage2 = stage(inputs = stage_inputs(str = stage1), body = function(str) print(str))
)
```

As you can see in the example above, dependencies between stages are specified using the `stage_inputs` function. You need to specify all parameters of the `body` function in the `inputs` parameter.

Run the pipeline using the `run_pipeline` function:

```{R}
stage_results <- run_pipeline(pipeline)
```

### Evaluation

Each stage input and result is an iterator. If a result from an input expression is not an iterator, then it will be wrapped in one. Every stage output is wrapped in an iterator.

This approach allows stages to keep granularity of their input:

```{R}
data <- list(
    list(number = 1, str = "a"),
    list(number = 2, str = "b"),
    list(number = 3, str = "c")
)

pipeline <- make_pipeline(
    stage1 = stage(inputs = stage_inputs(x = data %>% vec_to_iter()), body = function(x) {
        print("stage1 called")
        print(x)
        list(number = x$number * 2, str = x$str)
    }),
    stage2 = stage(inputs = stage_inputs(x = stage1), body = function(x) {
        print("stage2 called")
        print(x)
    })
)

stage_results <- run_pipeline(pipeline)
```

In this example, the first stage is called three times with each element of the `data` list. Since the first stage produced three results the second stage will be called again three times with each result.

If you would like to get all results from a previous stage, you can use the `collect_iter` function:

```{R}
data <- list(
    list(number = 1, str = "a"),
    list(number = 2, str = "b"),
    list(number = 3, str = "c")
)

pipeline <- make_pipeline(
    stage1 = stage(inputs = stage_inputs(x = data %>% vec_to_iter()), body = function(x) {
        print("stage1 called")
        print(x)
        list(number = x$number * 2, str = x$str)
    }),
    stage2 = stage(inputs = stage_inputs(x = collect_iter(stage1)), body = function(x) {
        print("stage2 called")
        print(x)
    })
)

stage_results <- run_pipeline(pipeline)
```

The `collect_iter` function collects all results from the first stage. That means the second stage is only called once.

If you would like to call a stage for each element of the previous stages result vector, you can use the `mapped` function:

```{R}
pipeline <- make_pipeline(
    stage1 = stage(body = function(x) {
        list(
            list(number = 1, str = "a"),
            list(number = 2, str = "b"),
            list(number = 3, str = "c")
        )
    }),
    stage2 = stage(inputs = stage_inputs(x = mapped(stage1)), body = function(x) {
        print("stage2 called")
        print(x)
    })
)

stage_results <- run_pipeline(pipeline)
```

The `mapped` function takes an iterator returning a single vector and converts the vector to an iterator. This allows you to effortlessly increase the granularity of the input.